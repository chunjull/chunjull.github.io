[{"title":"#53 DOM：文字節點","date":"2023-12-15T16:00:00.000Z","url":"/javascript/20231216/434066502/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"textContent 回傳純文字，而 innerText 則會回傳實際呈現在頁面上的樣子。 快速了解透過 textContent 與 innerText 可以選取並新增、修改、刪除文字節點。這兩者用途很相似，但仍有所區別。 textContent textContent 會獲取節點中所有元素的內容，包括 &lt;script&gt; 與 &lt;style&gt; 元素。且回傳節點中的每一個元素，故隱藏內容仍會在畫面中顯示，例如：下面案例的 &lt;span style=&quot;display:none;&quot;&gt;!!!&lt;/span&gt; 。 innerText innerText 會獲取「渲染後的文字內容」（rendered text content），即被 CSS 調整過樣式的文字。受 CSS 樣式影響，只會展示「實際所見的內容」，不會回傳隱藏元素的內容，且會觸發回流。 了解更多 MDN－innerText：了解 innerText 的概念。 MDN－textContent：了解 textContent 的概念。 Eason Lin－innerText 與 textContent：了解 innerText 與 textContent 的差異。 "},{"title":"#52 DOM：節點樣式","date":"2023-12-14T16:00:00.000Z","url":"/javascript/20231215/2022605776/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"可以透過 JS 修改 CSS 樣式，但盡量不要這麼做。 快速了解JS 有以下幾種常見的修改 CSS 樣式方法： 直接修改元素的 style 屬性。 透過修改 className 屬性或 classList 提供的 api 來修改元素的 class 屬性。 利用 JS 直接寫入 CSS 樣式。 修改元素的 style 屬性JS 修改元素的 style 屬性是對「行內樣式」進行修改。是透過 DOM api 修改元素的行內樣式，因此，樣式優先級會高過多數的其他樣式寫法（ !important 除外）。 特別注意！JS 的變數名稱及物件屬性名不允許使用 - 符號，所以在使用時要改為「駝峰式」寫法。 修改元素的 class 屬性由於 class 是保留的關鍵字，所以 JS 實際上是透過 className 來操作網頁標籤內的 class 屬性。 但是，當有多組 class 時，直接修改 className 內的值，不會保留原本的 class 屬性，原本的 class 會被覆蓋。為了解決這個問題， DOM api 新增了一組 classList 屬性來取代原本的 className ，讓原本的 class 屬性被保留。元素裡的 classList 屬性與 className 不同的是：它是一個「唯獨」的屬性。換言之，不能直接透過變更這個屬性來修改 DOM 的 class ，而是要利用 classList.add() 與 classList.remove() 修改它。 利用 JS 直接寫入 CSS 樣式常見的做法有兩種： 利用 document.write 在 &lt;head&gt; 寫入 CSS。 利用 document.createElement 新增 link 標籤。 透過這種方法的好處是：可以加入條件判斷來決定是否寫入 CSS 樣式。 小知識 通常來說，該交給 CSS 處理的樣式，就盡量不要用 JS 處理。 CSS 分為行內樣式（inline-style）與外部樣式（external），前者是直接在 HTML 元素的 style 屬性進行設定；後者則會透過 &lt;link&gt; 連接外部 CSS 檔案。 事實上，直接利用 JS 直接寫入 CSS 樣式是比較少見的做法，但在某些情況下確實是個實用的方式。 了解更多 Greta Ma－如何用 JS 更改 HTML &amp; CSS 屬性：了解動態更改元素樣式的方法。 "},{"title":"#51 DOM：節點刪除","date":"2023-12-13T16:00:00.000Z","url":"/javascript/20231214/2687438073/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"removeChild() 可以移除單一節點； innerHTML 則可以清空所有內容。 快速了解DOM 除了新增、修改等功能，還可以刪除節點。透過 removeChild() 方法，可以將指定的 childNode 子節點刪除。 上述程式碼在取得容器後，會先取得 &lt;li&gt;Item 02&lt;/li&gt; 元素，再將 myList 下的 removeNode 節點刪除。 清空元素的內容 removeChild() 只能移除單一的網頁節點，如果需要將某個元素的內容清空，可以使用 innerHTML ，就可以輕鬆將 myList 裡面的 HTML 一口氣清空。 了解更多 Kuro－DOM Node 的建立、刪除與修改：本文最主要的參考範例。 "},{"title":"#50 DOM：節點修改","date":"2023-12-12T16:00:00.000Z","url":"/javascript/20231213/1334002290/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"透過節點修改，可以將新增的 DOM 節點加入到指定位置。 快速了解前面提過：新增的元素或節點需要藉由 appendChild() 、 insertBefore() 或 replaceChild() 等方法加入到指定位置，才能顯示。這些方法可以將新建立的 DOM 節點置入到指定位置。 Node.appendChild(childNode)透過 appendChild() 可以將指定的 childNode 節點，加入到父容器節點的末端。 上述程式碼在取得容器後，會依序建立 &lt;li&gt; 元素與文字節點，再透過 appendChild() 將 textNode 加入到 newList ，最後，把 newList 置於 myList 的最後方，即可成功顯示。 Node.insertBefore(newNode, refNode)透過 insertBefore() 方法可以將新節點 newNode 插入到指定的 refNode 節點前面。 上述程式碼在取得容器後，會取得 &lt;li&gt;Item 02&lt;/li&gt; 元素並建立 li 元素和文字節點，再將 newNode 插入到 refNode 前方。 Node.replaceChild(newChildNode, oldChildNode)透過 Node.replaceChild() 可以將原本的 oldChildNode 替換成指定的 newChildNode 。 上述程式碼在取得容器後，會取得 &lt;li&gt;Item 02&lt;/li&gt; 元素並建立 li 元素和文字節點，再將原有的 oldNode 替換成新節點的 newNode 。 了解更多 Kuro－DOM Node 的建立、刪除與修改：本文最主要的參考範例。 "},{"title":"#49 DOM：節點新增","date":"2023-12-11T16:00:00.000Z","url":"/javascript/20231212/929725069/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"針對不同元素、節點，DOM 有不同的新增方式。 快速了解新增元素使用 document.createElement() 可以建立一個新元素。透過這個方式新增的元素，還需要藉由 appendChild() 、 insertBefore() 或 replaceChild() 等方法將其加入到指定位置，才能顯示。例如：針對新建立的 newDiv 元素加入指定的 id 與 class 屬性。 上述程式碼會建立一個新的 div 元素，再添加到 的最尾部。 新增文字節點使用 document.createTextNode() 可以建立文字節點，在括號內加入字串即可。和 document.createElement() 一樣，這個新增的文字節點在被加入到某個節點前，在瀏覽器上看不到。 新增 DocumentFragment DocumentFragment 是一種特殊的 DOM 節點，它是沒有父層節點的「最小化文件物件」。可以將其視為一個輕量化的 document ，用如同標準文件一般的方法來保存「片段的文件結構」。 上述程式碼會建立一個「有三個項目的列表清單」。 document.write()使用 document.write() 不只可以新增字串和 HTML 標籤，甚至可以加入 &lt;script&gt; 標籤。當網頁已經讀取完成後，才會執行 document.write() 並將內容輸出，這時新增的內容會完全覆蓋掉目前的網頁。 小知識 因為 DocumentFragment 不是真實的 DOM 結構，所以它的變動不會影響目前的網頁文件，也不會導致回流（reflow）或引起任何影響效能的情況。因此，當需要進行大量的 DOM 操作時，用 DocumentFragment 的效能會比較高。 不建議使用 document.write() 語法，詳情可參見 MDN 與 stackoverflow。 了解更多 Kuro－DOM Node 的建立、刪除與修改：本文最主要的參考範例。 MDN－DocumentFragment：了解 DocumentFragment 的概念。 ExplainThis－回流 (Reflow) 和重繪 (Repaint) 是什麼？：了解瀏覽器渲染的概念。 "},{"title":"#48 DOM：選取方式差異","date":"2023-12-10T16:00:00.000Z","url":"/javascript/20231211/497814301/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"DOM 選取方式有「選取結果」與「回傳結果」兩種差異。 快速了解DOM 選取方式主要有兩種差異：選取結果與回傳結果。 選取結果差異 document.getElementById 和 document.querySelector 必定只會取得單一元素或節點，所以沒有 index 與 length 屬性。 document.getElementsBy** 和 document.querySelectorAll 則會選取多個節點或元素。 選取方式 選取結果 有無 index 與 length 屬性 document.getElementById 單一元素或節點 無 document.querySelector 單一元素或節點 無 document.getElementsBy** 多個元素或節點 有 document.querySelectorAll 多個元素或節點 有 回傳結果差異 document.getElementsBy** 回傳 HTMLColleaction； document.querySelectorAll 則回傳 NodeList。HTMLCollection 只收集 HTML 元素節點，而 NodeList 除了 HTML 元素節點，也包含文字節點、屬性節點等。這兩種都可以用「陣列索引」的方式來存取內容。HTMLCollection 與 NodeList 在大部分情況是即時更新的——即「動態的」，但透過 document.querySelector 、 document.querySelectorAll 取得的 NodeList 則是靜態的。而 NodeList 和 HTMLCollection 的差別在於，NodeList 包含任何的節點類型，HTMLCollection 則只包含 HTML 元素節點 (Element nodes)。動態集合代表：隨後在 DOM 上面新增、修改、刪除節點的操作，都會直接反應在先前得到的元素集合結果中。 選取方式 回傳結果 集合型態 document.getElementsBy** HTMLCollection 動態集合 document.querySelector NodeList 通常是靜態，特殊情況是動態 小知識 注意！ document.getElementsBy** 的「Element」後面有個 s。 了解更多 Kuro－透過 DOM API 查找節點：本文最主要的參考範例。 Fooish－DOM 查找元素 (DOM Traversing)：了解 DOM 選取方式的差異。 "},{"title":"#47 DOM：節點關係","date":"2023-12-09T16:00:00.000Z","url":"/javascript/20231210/3807371373/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"DOM 節點是階層架構，有父子關係與兄弟關係兩種。 快速了解DOM 節點有分層的概念，大致可以把節點之間的關係分成兩種： 父子關係：除了 document 之外，每一個節點都會有個上層的節點，稱之為「父節點」（Parent node）；相對地，從屬於自己上層的節點被稱為「子節點」（Child node）。 兄弟關係：有同一個「父節點」的節點們，彼此之間互為「兄弟節點」（Sibling node）。 父子關係 Node.childNodes：可以取得子元素，回傳值可能會是元素節點、文字節點（包括空白）或註解節點。 Node.firstChild：可以取得 Node 節點的第一個節點，若無子節點則回傳 null 。 Node.lastChild：可以取得 Node 節點的最後一個節點，若無子節點則回傳 null 。 Node.parentNode：可以取得父元素，回傳值可能會是一個元素節點、根節點或 DocumentFragment 節點。 兄弟關係 Node.previousSibling：可以取得同層之間的前一個節點，若已是第一個節點則回傳 null 。 Node.nextSibling：可以取得同層之間的後一個節點，若已是最後一個節點則回傳 null 。 節點查找遍歷範例試著透過以下範例，檢驗自己對「節點查找遍歷」的了解： 小知識 基本上，隔層的節點沒有關係，所以並沒有爺孫節點、表堂兄弟節點這種存在。 NodeList 物件常被誤認為是陣列，雖然它同樣帶有 length 屬性且可以透過 [] 加上索引的方式來存取，但它只是一個特殊的「物件」，而不是陣列，因此原生陣列方法不適用於 NodeList 物件上。 Node.firstChild 和 Node.lastChild 的子節點包括「空白」節點。 Node.textContent 會回傳目標的字串內容或 null 。 了解更多 Kuro－透過 DOM API 查找節點：本文最主要的參考範例。 MDN－NodeList：了解 NodeList 物件的概念。 "},{"title":"#46 DOM：節點類型","date":"2023-12-08T16:00:00.000Z","url":"/javascript/20231209/4150368758/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"DOM 有多種節點類型與常數。 快速了解 document 物件是整個 DOM tree 的根節點，因此，要存取 HTML 時，都是從 document 物件開始。DOM 節點類型除了「元素節點」（element nodes）外，還有「文字節點」（text nodes）、「註解節點」（comment nodes）。 節點類型整理常見的 DOM 節點類型常數 （Node type constants）有以下幾種： 節點類型常數 對應數值 說明 node.ELEMENT_NODE 1 HTML 元素的 Elements 節點 node.TEXT_NODE 3 實際文字節點，包含換行與空格 node.COMMENT_NODE 8 註解節點 node.DOCUMENT_NODE 9 根節點（Document） node.DOCUMENT_TYPE_NODE 10 文件類型的 Document 節點，例如： &lt;! DOCTYPE html&gt; 。 node.DOCUMENT_FRAGMENT_NODE 11 DocumentFragment 節點 可以透過 nodeType 屬性判斷「常數」或「對應數值」來判斷節點類型。 了解更多 Kuro－透過 DOM API 查找節點：本文最主要的參考範例。 Fooish－DOM 節點物件的屬性：了解更多種 DOM 節點物件的屬性。 "},{"title":"#45 DOM：節點選取","date":"2023-12-07T16:00:00.000Z","url":"/javascript/20231208/747586579/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"DOM 有多種選取方式，例如：標籤名稱、class、id、選擇器等。 快速了解常見的 DOM 選取方法有以下幾種： 針對給定的 tag 名稱，回傳所有符合條件的集合。 針對給定的 class 名稱，回傳所有符合條件的集合。 針對給定的 Selector 名稱，回傳第一個符合條件的集合。 針對給定的 Selector 名稱，回傳所有符合條件的集合。 節點選取範例試著在 HTML 檔案中選取 h1 標籤。 小知識 document.querySelector 與 document.querySeletorAll 可以用「CSS 選擇器」來取得「第一個」或「所有」符合條件的元素集合（NodeList）。 了解更多 Kuro－透過 DOM API 查找節點：本文最主要的參考範例。 MDN－CSS 選擇器：了解 CSS 選擇器的概念。 "},{"title":"#44 DOM 環境配置","date":"2023-12-06T16:00:00.000Z","url":"/javascript/20231207/2560653094/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"將 &lt;script&gt; 標籤放在 &lt;/body&gt; 之前，才能讓網頁被完整解析成 DOM tree。 快速了解通常來說，JS 的 &lt;script&gt; 標籤有兩種擺放位置： 放在 &lt;head&gt; ... &lt;/heade&gt; 之間。 放在 &lt;/body&gt; 之前。然而，放在 &lt;head&gt; ... &lt;/heade&gt; 之間的 JS 卻可能無法作用，這跟瀏覽器的執行原理有關。 瀏覽器執行原理當網頁被載入到瀏覽器時，瀏覽器會先分析該 HTML 檔案，由上往下依序讀取分析。如果瀏覽器在 &lt;head&gt; ... &lt;/heade&gt; 之間遇到 &lt;script&gt; 標籤，就會暫停解析網頁，並且立即執行 &lt;script&gt; 裡的內容，直到所有內容都執行完畢後，才會再繼續解析網頁。這樣的情況會導致 JS 無法作用的結果，因為在 &lt;head&gt; ... &lt;/heade&gt; 之間的 &lt;script&gt; 試圖去尋找「尚未被解析到的 HTML 內容」，卻無從取得，最後只能呈現「JS 無法作用」的狀態。但如果瀏覽器是在 &lt;/body&gt; 之前才讀取到 &lt;script&gt; 標籤，由於該網頁已經解析成 DOM 節點，使 JS 可以順利操作網頁節點，成功顯示開發者欲展現的內容。 了解更多 Kuro－透過 DOM API 查找節點：本文最主要的參考範例。 #43 DOM 的差別與重要性：回顧網頁載入流程。 "},{"title":"#43 DOM 的差別與重要性","date":"2023-12-05T16:00:00.000Z","url":"/javascript/20231206/1110551957/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"了解 BOM 與 DOM 的區別就是明白如何操作網頁的第一步。 快速了解前面介紹過，DOM 的 document 其實也是 BOM window 物件的子物件之一。 BOM 與 DOM 的區別BOM 與 DOM 的區別在於： BOM：是 JS 與「瀏覽器」溝通的窗口，不涉及網頁內容；本身無標準規範，完全依賴於瀏覽器廠商實作。 DOM：是 JS 用來控制「網頁」的節點與內容的標準；有 W3C 所制定的規範標準。 DOM 的重要性只要遵守 W3C 制定的規範，不管是任何平台或任何開發語言，都可以透過 DOM 提供的 API 來操作 DOM 的內容、結構與樣式。當一個網頁被載入到瀏覽器時，瀏覽器會先分析這個 HTML 檔案，再依照這份內容解析成 DOM。換句話說，DOM 是網頁的根本，懂得控制 DOM 就可以控制整個網頁，做出良好的互動體驗。對於前端工程師來說，了解如何與瀏覽器打交道、如何運用 JS 操作網頁內容，就是做好 WebUI 最重要的基礎。 了解更多 Kuro－前端工程師的主戰場：瀏覽器裡的 JavaScript：本文最主要的參考範例。 "},{"title":"#42 DOM","date":"2023-12-04T16:00:00.000Z","url":"/javascript/20231205/2401154791/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"DOM API 讓 JS 可以對操作網頁內容。 快速了解DOM（Document Object Model），文件物件模型，是一個將 HTML 文件以樹狀結構來呈現的模型。其組合起來的樹狀圖被稱為「DOM tree」。DOM 會把 HTML 文件行程一個個「節點」（node），再組成一個樹狀結構。在最根部的位置，是 document 。往下延伸出 HTML 標籤節點，一個節點就是一個標籤（Element）。再往下又可以延伸出「文本節點」（Text）與「屬性節點」（Attribute）。 DOM 選取方式DOM API 定義了多種方法，讓 JS 可以存取、改變 HTML 架構、樣式和內容，甚至可以對節點綁定事件。使用 JS 取得網頁中元素的方式有很多種，例如： 根據 id 名稱選取： document.getElementById() 。 根據元素名稱選取所有符合條件者： document.getElementsByTagName() 。 根據 class 名稱選取所有符合條件者： document.getElementsByClassName() 。 根據條件選取第一個符合條件者： document.querySelector() 。 根據條件選取所有符合條件者： document.querySelectorAll() 。總結來說，JS 就是透過 DOM 提供的 API 來對 HTML 進行存取與操作。 小知識 document 是 window 物件的其中一種屬性。 了解更多 Kuro－前端工程師的主戰場：瀏覽器裡的 JavaScript：本文最主要的參考範例。 陳奕帆 Andy Chen－深入理解網頁架構：DOM：了解 DOM tree 的結構。 "},{"title":"#41 BOM","date":"2023-12-03T16:00:00.000Z","url":"/javascript/20231204/3425939589/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"BOM 有兩種功能：全域物件與瀏覽器溝通窗口。 快速了解BOM（Browser Object Model），瀏覽器物件模型，是瀏覽器所有功能的核心，與網頁的內容無關。 window 物件BOM 的核心是 window 物件。 window 物件提供的屬性主要有 document 、 location 、 navigator 、 screen 、 history 及 frames 。在瀏覽器裡的 window 物件扮演著兩種角色： ECMAScript 標準裡的「全域物件」（Global Object）。 JavaScript 用來與瀏覽器溝通的窗口。 全域物件作為 JavaScript 的全域物件， window 物件包含了所有全域變數與函式，通常會把這些變數稱為「全域變數」，可以透過 window.xxx 取得它們。 在「全域作用範圍」宣告的全域變數雖然屬於 window 的屬性，但它無法使用 delete 關鍵字移除。 但如果是直接透過指定 window 物件的屬性，就可以成功刪除。 瀏覽器的溝通窗口瀏覽器環境的 BOM 與 window 物件提供了多種內建功能的 API，例如：開啟或關閉視窗、改變視窗大小、計時器與取得網址等。window 物件只需要一行程式碼即可生成一個對話框。舉例來說：用 alert() 產生一個「警告對話框」。 實際上， window.alert(&quot;Hello!&quot;); 才是完整語法，但因為全域物件的特性， window 可以省略不打。 小知識 BOM 有時被稱為「Level 0 DOM」，是因為它在 DOM Level 1 標準前就已存在，而非真的有文件規範。 在「全域作用範圍」內宣告的變數、物件、函式，都會自動變成「全域物件」的屬性。 了解更多 Kuro－前端工程師的主戰場：瀏覽器裡的 JavaScript：本文最主要的參考範例。 MDN－Window：了解更多 window 物件的屬性與方法。 Samuel－BOM和DOM筆記：觀看常用的 window 屬性及說明。 #34 全域變數與區域變數：回顧「全域物件」的概念。 "},{"title":"#40 瀏覽器與 JS","date":"2023-12-02T16:00:00.000Z","url":"/javascript/20231203/1229881720/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"瀏覽器提供網頁的操作方法，讓 JS 可以網頁中運作。 快速了解在學習前端知識時，你可能聽過這個說法：「HTML、CSS 與 JavaScript 是網頁前端三大要素」。由 HTML 負責資料與結構，CSS 負責樣式與呈現，JavaScript 負責行為與互動。但事實上，JS 並沒有提供網頁的操作方法，前端開發者在網頁上的操作方法都由 JS 的執行平台——「瀏覽器」提供。基本上，這些操作方法會分別由「BOM」與「DOM」這兩種物建所擁有。因此，在瀏覽器上的 JS 包含了三個部分： JavaScript 核心（以 ECMAScript 標準為基礎） BOM（Browser Object Model，瀏覽器物件模型） DOM（Document Object Model，文件物件模型）前端開發者就是透過 JS 去呼叫 BOM 與 DOM 提供的 API，再進一步透過它們去控制瀏覽器的行為與網頁的內容。 小知識 瀏覽器都會包含一個渲染引擎（rendering engine），負責解釋網頁上的程式碼，瀏覽器的 JS 解譯器就是該引擎的一部份。 了解更多 Kuro－前端工程師的主戰場：瀏覽器裡的 JavaScript：本文最主要的參考範例。 "},{"title":"#39 可變的","date":"2023-12-01T16:00:00.000Z","url":"/javascript/20231202/1332088474/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"物件型別的「可變」特性，使其內容可以直接被更新。 快速了解JS 的型別中，只有物件型別是可變的（Mutable），並且會透過「傳址」方式傳遞參數。換句話說，物件型別以記憶體的「位址」為基準，來進行更新或複製，並非以「值」為基準。因此，當物件更新時，會影響到所有引用該物件的變數與其副本。 物件更新因為可變的特性，呼叫某些函式時，有可能會更動到原本記憶體位置儲存的東西。 在原本的陣列 arr 透過 arr.push 的方式呼叫，會更動到原本的陣列，使最後印出結果為 [2, 4, 6, 8] 。這時，如果使用「重新賦值」的方式印出結果，將會產生不同的內容。 在上述案例中，重新賦值會讓原本的陣列做兩件事情：新增元素到陣列、回傳陣列長度（arr.length）。使得最後印出結果變成陣列長度的 4 。 小知識 通常來說，不會改動到陣列的「內建函式」，其回傳結果都不是陣列，例如： array.join() 回傳結果為字串。 了解更多 文科少女學程式－JavaScript的mutable與immutable：詳細了解「可變的」意義。 #36 參數傳遞：Pass by reference：回顧「傳址」方式。 "},{"title":"#38 不可變的","date":"2023-11-30T16:00:00.000Z","url":"/javascript/20231201/2821490299/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"基本型別的「不可變」特性，使其值必須重新賦值才能更新。 快速了解除了物件以外，其他基本型別（primitive types）都具有不可變的特性，並且會透過「傳值」方式傳遞參數。換句話說，基本型別以「值」為基準，而不是以「址」為基準，每個值都是獨立的，就算值看起來是相等的，其所佔的記憶體位置也不一樣。 純值的重新賦值因為不可變的特性，原本的值和後來的值是完全獨立的關係，必須要透過 = 重新賦值，才能讓後來的值取代原本的值。 變數 a 原本的值為「hello」，在宣告時被儲存在 0x01 的位置；被重新賦值時，後來的值「yo」不會取代舊值的位置，而是建立新的記憶體空間 0x02 來存放。 內建函式的重新賦值由於字串具有不可變的特性，因此，不論呼叫什麼函式均無法改變 a 的值。必須要透過重新賦值，才能更新原本的值。 在範例一，試著透過內建函式 toUpperCase() 呼叫，使變數 a 的字串更新為大寫。但如果只對基本型別的值進行呼叫，不會有任何改變，回傳結果仍是原本的值—— hello 。而範例二，則透過重新賦值的方式，讓變數 a 指向了新的記憶體位置——即 toUpperCase() 的結果，才成功印出更新的值 HELLO 。 了解更多 文科少女學程式－JavaScript的mutable與immutable：詳細了解「不可變的」意義。 #35 參數傳遞：Pass by value：回顧「傳值」方式 "},{"title":"#37 參數傳遞：Pass by sharing","date":"2023-11-29T16:00:00.000Z","url":"/javascript/20231130/3304160290/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"事實上，JS 是以 Pass by sharing 的方式傳遞參數。 快速了解大多數情況下，基本型別是「傳值」，物件型別是「傳址」。但實際上，JS 不屬於單純的「傳值」或「傳址」。準確來說，JS 是透過「Pass by sharing」的方法來傳遞參數。 Pass by sharingPass by sharing 的特點在於：當 function 的參數被重新賦值時，外部變數的內容不會被影響。而如果不是重新賦值的情況，則會跟 Pass by reference 的結果一樣。 可變的與不可變的JS 型別具有兩種特性：可變的（mutable）與不可變的（immutable）。物件型別是可變的，代表當物件更新時，會影響到所有引用這個物件的變數與其副本，修改時會變動到原本的參考。但在賦與新值時，卻會產生新的實體參考。基本型別則是不可變的，代表更新某個基本型別的值時，與該值的副本完全無關。在操作基本型別時，Pass by sharing 與 Pass by value 的結果一樣，修改時永遠只能賦與新值。 小知識 參數傳遞方式與 JS 的深拷貝（Deep copy）、淺拷貝（Shallow copy）方法相關。 了解更多 Kuro－JavaScript 是「傳值」或「傳址」？：本文最主要的參考範例。 itsems－Javascript中的傳值 by value 與傳址 by reference：了解 Pass by sharing 方法。 Huli－深入探討 JavaScript 中的參數傳遞：深入了解參數傳遞與深、淺拷貝方法。 "},{"title":"#36 參數傳遞：Pass by reference","date":"2023-11-28T16:00:00.000Z","url":"/javascript/20231129/1891124894/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"物件型別是以 Pass by reference 的方式傳遞參數。 快速了解物件型別指的是可能由零或多種不同型別（包含純值與物件）所組成的物件。在比較、更新與傳遞時，會以「實體參考」的形式進行，這種參數傳遞方式被稱為「傳址」（Pass by reference）。 物件型別的比較JS 的物件可以被視為是一個「實體」（instance）。對於兩個不同的實體來說，即使它們內容的「值」一樣，也不表示它們相等。 雖然 box1、box2 看起來「等值」，但這並不是「box1 等於 box2 」的意思。 物件型別的更新與傳遞物件是透過「引用」方式傳遞資料，接收的對象是引用的「參考」而不是「值」的副本。因此，當被引用的參考內容被更新時，引用者的內容也會一併更新。在此時，透過 === 去檢查兩個實體，會發現兩者實際上是同一個實體。 這個流程是這樣運作：首先在建立一個物件時，JS 會在記憶體某處建立一個物件，再將 box1 變數指向該新生成的物件。接著，宣告第二個變數 box2 後，透過 = 將其指向 box1 的位置。最後，當 box1.value 的內容更新，box2.value 也一起被更新。 了解更多 Kuro－JavaScript 是「傳值」或「傳址」？：本文最主要的參考範例。 itsems－Javascript中的傳值 by value 與傳址 by reference：了解傳址方法。 "},{"title":"#35 參數傳遞：Pass by value","date":"2023-11-27T16:00:00.000Z","url":"/javascript/20231128/1868702299/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"基本型別是以 Pass by value 的方式傳遞參數。 快速了解基本型別內的資料，會以純值的形式存在。在比較、更新與傳遞時，也會以「值」的形式進行，這種參數傳遞方式被稱為「傳值」（Pass by value）。 基本型別的比較在基本型別時，會透過變數裡面的內容——即「值」——來判斷兩個變數是否相等。 基本型別的更新與傳遞在基本型別的變數中，看的是變數裡的「值」。舉例來說，在複製變數時，複製的是該變數的「值」。 變數 b 的值是透過複製變數 a 的值而來。但這不代表當變數 a 更新後，會影響變數 b 的數值： 變數 a、b 是各自獨立的，變數 b 看起來是透過複製變數 a 而來，實際上，是變數 b 建立了一個新的值，再將變數 a 的內容複製過去。因此，當變數 a 的內容後來經過更新變成 100 後，變數 b 的內容不受影響，依然是原本的 10。 了解更多 Kuro－JavaScript 是「傳值」或「傳址」？：本文最主要的參考範例。 itsems－Javascript中的傳值 by value 與傳址 by reference：了解傳值方法。 "},{"title":"#34 全域變數與區域變數","date":"2023-11-26T16:00:00.000Z","url":"/javascript/20231127/3502683458/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"實際上，全域變數是指「全域物件」的屬性。 快速了解其實在 JS 中，並不存在「全域變數」。更準確地說，我們所說的「全域變數」是指「全域物件」（或稱「頂層物件」）的屬性。 全域物件以瀏覽器來說，「全域物件」指的是 window ，在 node 環境中則叫做 global 。全域物件的「屬性」是什麼意思呢？來看看下面的範例： 在前面章節中，我們一直稱呼 var a = 10; 為「全域變數」，但當我們想印出 window.a 時，會獲得的結果即是 10 ！因此，「全域變數」是指全域物件的「屬性」。 變數整理 變數有效範圍的最小切分單位是 function ， let 和 const 除外。 let 和 const 是區域變數，以大括號 &#123;&#125; 區塊的程式碼為作用範圍。 即使寫在函式內，沒有 var 宣告的變數都會變成「全域變數」。 全域變數指的是全域物件（頂層物件）的「屬性」。 了解更多 Kuro－函式的基本概念：本文最主要的參考範例。 Tim－全域變數與區域變數：了解全域變數與區域變數的概念。 #8 資料型別：物件：回顧物件的屬性觀念。 "},{"title":"#33 暫時性死區","date":"2023-11-25T16:00:00.000Z","url":"/javascript/20231126/1744441320/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"let 與 const 的宣告提升時，會產生暫時性死區。 快速了解暫時性死區（Temporal Dead Zone, TDZ）是只有 let 與 const 才具有的特性，專門用來解釋它們的提升行為。 let 與 const 的提升 let 與 const 也有提升，差別在於： var 提升之後，宣告的變數會被初始化為 undefined ；而 let 與 const 的宣告則不會被初始化為 undefined，如果在「賦值之前」就存取它，就會發生錯誤。具體來說，在「提升之後」及「賦值之前」這段期間，如果存取該變數就會拋出錯誤，這段期間被稱為「暫時性死區」（TDZ）。受到 TDZ 影響，變數需要在宣告後才能使用。如果在 let 與 const 宣告前讀取變數，會引發 Uncaught ReferenceError 的錯誤。因此，不論是用何種宣告方式，使用變數前一定要先宣告。 函式宣告除了變數，函式也有提升。兩者差異為：變數提升只有宣告被提升；函式的提升則是包括內容都完全被提升。因此，函式提升優先於變數提升。函式定義方式也會有差異。透過函式宣告定義的函式，因為函式提升，可以在宣告前使用。 透過函式運算式定義的函式則會出現錯誤。 小知識 除了可呼叫的時機不同外，「函式宣告」與「函式運算式」在執行時期沒有明顯的差別。 了解更多 Kuro－函式的基本概念：本文最主要的參考範例。 阿建－JavaScript 提升(Hoisting)是什麼?關於提升的5個觀念：回顧變數提升的概念。 #26 函式：定義：回顧函式定義方式。 "},{"title":"#32 變數提升","date":"2023-11-24T16:00:00.000Z","url":"/javascript/20231125/3405801099/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"「提升」使得變數在宣告之前被使用會回傳 undefined 。 快速了解變數提升（Variables Hoisting）會把變數和函數的宣告移動到程式區塊頂端，直到實際執行時再賦值。看起來是將變數和函數的宣告「移動」到程式區塊頂端。但在編譯階段時，變數和函式的宣告會先被放入記憶體，實際在程式碼中位置還是一樣。換言之，如果在宣告前使用相應的變數，瀏覽器會先將該變數「提升」至程式區塊頂端並宣告，但尚未賦值，因此，此時會印出 undefined ，直到程式執行到相關的宣告程式碼時，才會賦值。舉例來說： 在宣告變數 word 時尚未賦值，只會印出 undefined 的結果；直到變數 word 被執行並賦值時，才會回傳 hello 的結果。 進階案例 在這個案例中， console.log(x) 的回傳值會是 undefined 。因為，對瀏覽器來說，這時的程式碼會呈現下面的樣子： JS 會先在自己的作用域尋找變數 x ，發現在下面的 var x = 100 有宣告，就只會把「宣告的語法」提升到該作用域（即這個案例的 function ）的最上面，因此只會印出 undefined 的結果。 解決方式為了解決 JS 「變數提升」的奇怪特性，建議使用以下兩種方式： 先宣告再使用，所有可能用到的變數都盡量在「作用域的最上面」宣告完成後再使用。 使用 ES6 的 let 或 const 代替，因為 let 宣告的變數不會有變數提升的特性。 小知識 只有宣告的變數會提升，賦值不會提升。 了解更多 Kuro－函式的基本概念：本文最主要的參考範例。 MDN－提升：了解變數提升的概念。 阿建－JavaScript 提升(Hoisting)是什麼?關於提升的5個觀念：了解變數提升的概念。 Huli－我知道你懂 hoisting，可是你了解到多深？：深入了解變數提升的概念。 "},{"title":"#31 變數的有效範圍","date":"2023-11-23T16:00:00.000Z","url":"/javascript/20231124/3746595863/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"除了 let 與 const ，切分變數有效範圍的最小單位是 function 。 快速了解變數的有效範圍被稱為「作用域」（Scope），而切分變數有效範圍的最小單位是 function 。在 ES6 之前，JS 變數有效範圍的最小單位是以 function 作為分界。（ES6 新增的 let 與 const 例外）舉例來說： 上述程式碼代表著：在函式區塊內透過 var 定義的 x 變數只屬於這個函式，函式外的 x 與函式內的 x 是兩個不同的變數。因此， doSomeThing(50) 會印出 100 + 50 的 150 ； x 則會印出函式外面的 1 。 找不到指定變數的情況 如果 function 內沒有 var x 的話，在自己的 內沒有找到，就會一層層往外找，直到「全域變數」為止。 沒有 var 宣告變數的情況在下面案例中，把 function 內的 var 拿掉。 因為「切分變數有效範圍的最小單位是 function 」的特性，如果 function 內部沒有使用再次用 var 宣告某變數，JS 就會再往外層查找有無同名的變數，直到最外層的「全域物件」為止。因此，這會使得 function 內的 x = 100 變更了外層的同名變數 x 。 小知識 與 var 不同， let 與 const 的作用域是透過大括號 &#123;&#125; 來切分，且 let 不允許重複宣告。 函式外層無法使用內層宣告的變數，但內層可以使用外層的變數。 最外層的「全域物件」，以瀏覽器來說，就是 window 了解更多 Kuro－函式的基本概念：本文最主要的參考範例。 Lochs－Scope 作用域：了解三種作用域概念與預習作用域鏈的觀念。 "},{"title":"#30 變數宣告","date":"2023-11-22T16:00:00.000Z","url":"/javascript/20231123/704880787/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"變數宣告與後續會提到的 JS 觀念息息相關。 快速了解我們之前介紹過，變數有三種宣告方式： var 、 let 、 const 。過去通常會使用 var 宣告變數，直到 ES6 新增了區域變數 let 、 const ，開發者們逐漸以此取代 var 。 var 宣告對象為變數（Variable）。 變數有效範圍為函式作用域。 允許重複宣告。 可以重新賦值。 宣告前就存取對應變數，會得到 undefined 。 let 宣告對象為變數（Variable）。 變數有效範圍為區塊作用域，是區域變數。 同一個區塊作用域中不允許重複宣告。 可以重新賦值。 宣告前就存取對應變數，會得到 ReferenceError 錯誤。 const 宣告對象為常數（Constant）。 變數有效範圍為區塊作用域，是區域變數。 同一個區塊作用域中不允許重複宣告。 不可以重新賦值。 宣告前就存取對應變數，會得到 ReferenceError 錯誤。 宣告時一定要給值。 宣告方式整理 var let const 宣告對象 變數 變數 常數 有效範圍 函式作用域 區塊作用域 區塊作用域 能否重複宣告 可 同一個區塊作用域中不可 同一個區塊作用域中不可 能否重新賦值 可 可 不可 宣告強度 弱 中 強 嚴謹程度 低 高 高 小知識 var 與 let 的差別在於： var 是以 function 為作用域； let 則是以大括號 &#123;&#125; 區塊的程式碼為作用的範圍。 了解更多 ㄚ淳淳－const、let、var的區別—DAY3：了解三種宣告的差異與練習題目。 popeye_ux－變數宣告var、let、const的區別：透過案例了解三種宣告的差異。 程式碼農－JS 宣告變數， var 與 let &#x2F; const 差異：了解更詳細的三種宣告差異。 "},{"title":"#29 常用的內建函式：Array","date":"2023-11-21T16:00:00.000Z","url":"/javascript/20231122/154092581/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"學習 Array 內建函式，可以讓程式碼更簡潔。 快速了解內建函式可以讓程式碼更簡潔，但並非必要，使用一般程式碼也可以完成這些功能。以下分享一些 Array 常用的內建函式。 join.() ：將陣列中所有元素連接成一個字串，預設分隔符是逗號。 map() ：把陣列中的每個元素帶入指定函式，然後建立一個新的陣列。 filter() ：概念和 map() 類似，會根據指定的測試函數，從一個陣列中過濾出符合條件的元素，並建立新的陣列。 slice() ：可截取出陣列某部份元素，會建立一個新的陣列，其意義為「自哪一個索引開始提取，到哪一個索引之前結束」。 splice() ：可用來刪除與新增元素，會改變原本的陣列。 sort() ：依照字母順序排列陣列中的所有元素，會改變原本的陣列。 小知識 在使用 sort() 時，因為數字被轉換成字串，在 Unicode 順序中 &quot;80&quot; 會在 &quot;9&quot; 的前面。 了解更多 MDN－Array：了解 Array 的常見函式。 "},{"title":"#28 常用的內建函式：String","date":"2023-11-20T16:00:00.000Z","url":"/javascript/20231121/1909286593/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"學習 String 內建函式，可以讓程式碼更簡潔。 快速了解內建函式可以讓程式碼更簡潔，但並非必要，使用一般程式碼也可以完成這些功能。以下分享一些 String 常用的內建函式。 toUpperCase 、 toLowerCase ：將字串轉換大、小寫。 .charCodeAt() ：取得字串特定位置的字元 ASCII 編碼。 String.fromCharCode()：將 ASCII 編碼的數字轉換成字元。 indexOf() ：可回傳「指定字串」在字串中第一次出現的位置，若找不到則回傳 -1。 replace() ：取代字串，只能換第一個指定字串。 split() ：透過「指定分隔符」來分開字串，回傳值為陣列。 trim() ：移除目前字串開頭和結尾的所有空格。 string.length ：可回傳字串長度，常搭配迴圈使用。備註：此指令不是函式。 ASCIIASCII 是「美國標準資訊交換碼」，每一個可顯示字元都有自己專屬的索引，大、小寫字母的索引相差 32。 利用 ASCII code 進行字串比大小，可判斷該字元為大小寫、是否在條件範圍內： 如果想要取代「所有的」指定字串，可以使用正規表達式（Regular expressions）達成： 了解更多 MDN－String：了解 String 的常見函式。 維基百科－ASCII：了解 ASCII 編碼的意義。 MDN－正規表達式：了解正規表達式的使用方式。 "},{"title":"#27 常用的內建函式：Number","date":"2023-11-19T16:00:00.000Z","url":"/javascript/20231120/576908797/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"學習 Number 內建函式，可以讓程式碼更簡潔。 快速了解內建函式可以讓程式碼更簡潔，但並非必要，使用一般程式碼也可以完成這些功能。以下分享一些 Number 常用的內建函式。 Number() ：將字串轉數字。 parseInt() ：將字串轉整數，預設為十進位，例如：parseInt(a, 10) 。 parseFloat() ：將字串轉浮點數，即有小數點。 toFixed() ：取到小數點後第幾位，括號內不輸入就會取整數。 .toString()：數字轉字串。 Number.MAX_VALUE 、 Number.MIN_VALUE ：得知在 JS 可儲存的最大、最小值，若超出這個值，計算就會不精準。 Math.PI ：圓周率。Math.ceil() ：無條件進位，取大於這個數的最小整數。 Math.floor() ：無條件捨去，取小於這個數的最大整數。 Math.round ：四捨五入。 Math.sqrt()：開根號。 Math.pow(x, y)：次方，取 x 的 y 次方。 Math.random ：產生 0～1 之間的隨機小數（不包含 1） 。 小知識 常數會用大寫英文字母表示，例如： PI 。 toFixed() 常與 parseFloat() 搭配使用。 數字轉字串的另一個方式：數字加空字串（ &#39;&#39; 或 &quot;&quot; ）。 了解更多 MDN－Number：了解 Number 的常見函式。 MDN－Math：了解 Math 的常見函式。 "},{"title":"#26 函式：定義","date":"2023-11-18T16:00:00.000Z","url":"/javascript/20231119/115912181/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"函式有三種定義方式，並可分為具名、匿名兩種。 快速了解函式有三種定義方式： 函式宣告（Function Declaration）。 函式運算式（Function Expressions）。 透過關鍵字 new Function 建立函式。 函式宣告「函式宣告」是最常見的用法。 函式運算式將函式透過 = 指定給某個變數。 透過關鍵字 new Function 建立函式。因效能較差，實務上較少使用。使用關鍵字 new Function 建立函式物件。將參數與函式的內容依序傳入 Function ，即可建立一個函式物件。 匿名函式在前面「函式運算式」的範例中，可以發現：該函式是「沒有名字」的。這種沒有名字的函式被稱為「匿名函式」。 小知識 有名字的「具名函式」只在「自己函式的區塊內」有效，換言之，脫離函式自身的 &#123;&#125; 區塊後，該變數就不存在。 了解更多 Kuro－函式的基本概念：本文最主要的參考範例。 MDN－函式：了解函式的常見用法。 Tim－具名函式與匿名函式的基本認識：了解匿名函式的使用方式。 OneJar－函數定義 (Function Definition) 的 100 種寫法：了解更多種函式定義方式。 "},{"title":"#25 函式：宣告","date":"2023-11-17T16:00:00.000Z","url":"/javascript/20231118/1806621739/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"函式是物件的一種，具有可重複使用的特性。 快速了解函式（function）會將一或多段程式指令包裝起來，可以重複使用，也方便維護。可以同時註冊多組函式，函式裡也可以執行其他函式。 函式結構通常來說，一個函式會包含以下三個部分： 函式名稱（備註：也可能沒有名稱）。 在小括號中的部分為「參數（arguments）」，參數與參數之間會用逗號隔開（備註：不一定需要參數，但括號不可省略）。 大括號中則是需要「重複執行」的內容，是函式功能的主要區塊。 函式呼叫所有的函式都有回傳值，回傳值可以用關鍵字 return 來指定。定義為：宣告一個變數，其值為函式，待函式執行完， return 會將結果為傳至函式，並賦予到變數上。如果沒有使用 return 回傳，預設會回傳 undefined 。 函式範例 function ：使用關鍵字 function 宣告一個函式。 totalPrice ：函式名稱。 (item1, item2) ：參數。 return item1 + item2; ：會回傳的執行區塊。 oldList 、 newList ：宣告變數， return 會把結果傳到函式，再賦予至變數。 小知識 使用 typeof 檢查一個函式時，會得到 function 的結果。但實際上，函式仍屬於物件型別（ object ）。 參數跟變數不同，參數只存活在大括號裡。在函式外，印出參數會回傳錯誤。 函式可以分成兩種：不需要知道結果、需要回傳值。前者有無 return() 並不影響結果，通常只會用 console.log() 印出結果；後者則必須要透過 return() 得到回傳值。 了解更多 Kuro－函式的基本概念：本文最主要的參考範例。 MDN－函式：了解函式的常見用法。 "},{"title":"#24 變數儲存模型","date":"2023-11-16T16:00:00.000Z","url":"/javascript/20231117/1831802184/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"記憶體儲存概念：一般的東西存資訊，物件存記憶體位置。 快速了解說到「變數資料」與「記憶體存放」的觀念，就必須先了解：在任何一個程式語言中，操作資料前，你會需要先找到一個地方放置這些資料，這個地方就是「變數」。變數會提供一個「暫時儲存資料」的地方，透過一個可以識別的名字，將資料寫進記憶體。 記憶體存放流程變數與資料操作的實際情況，在電腦上發生的是： 你在記憶體上宣告（declare）了一組變數。 你在記憶體上創建（create）了一筆資料。 變數指向（assign）這筆資料。以下列程式碼為例： 使用 let 的方式，宣告一個名為 appleColor 的變數，並對應到一筆 &quot;red&quot; 的資料。 物件型別的情況如果想存物件或陣列，變數裡面存的內容是「指引」或「指標」，是前往某個記憶體位置的指引。換句話說，基本型別的變數存資訊，物件則存在記憶體位置。 了解更多 Huli－從博物館寄物櫃理解變數儲存模型：最白話的案例帶你了解變數儲存。 MDN－記憶體管理：深入了解 JS 的記憶體管理。 ALPHACamp－變數與值：複習變數與值的關係。 "},{"title":"#23 迴圈：break 與 continue","date":"2023-11-15T16:00:00.000Z","url":"/javascript/20231116/2461366595/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"break 和 continue 都能中斷迴圈，但兩者的功能並不同。 快速了解使用迴圈時，有時會需要跳過其中幾次或提早離開迴圈。這時，可以使用 break 和 continue 語法。 break 語法 break 會直接跳離迴圈。例如：在包含一堆 0 和其他數字的陣列中找出不是 0 的「第一個數字」。 找出那個不是 0 的「第一個數字」，印出後再退出迴圈。 continue 語法 continue 會跳過一次，再繼續下一次的迴圈。例如：當我們要印出 1～10 的所有正整數，但跳過 3 的倍數。 在此案例中， i 能被 3 整除表示 i 是 3 的倍數，遇到 continue 則會跳過。 小知識 在迴圈中，可能會常看到 arr.length 的類似語法，這代表「陣列的長度」，常被放在 for 的條件部分。 了解更多 Kuro－流程判斷與迴圈：本文最主要的參考範例。 MDN－break 語法：了解 break 的常見用法。 MDN－continue 語法：了解 continue 的常見用法。 ALPHACamp－Loop 迴圈：了解 JS 的迴圈用法。 "},{"title":"#22 迴圈：while","date":"2023-11-14T16:00:00.000Z","url":"/javascript/20231115/1598197283/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"相較於 for 迴圈， while 語法更單純易懂。 快速了解 for 和 while 這兩種迴圈語法的原理大同小異，但相較 for 語法， while 迴圈的語法更單純一些。 while 迴圈 while 語法只由條件組成。小括號內是「執行迴圈的條件」，指滿足該條件時，會進入大括號區塊，再執行內部程式。 以上述為例： i = 0 是初始值。 i &lt; 10 是條件。 i++ 是結束迴圈的更新敘述。 console.log(i) 是敘述，即函式要做的事。 for 與 while 的差異 for 和 while 迴圈的特性都是「只要指定條件是 true 」就可以進入重複執行的區塊，因此，在大部分情況下，它們兩者能做的事情一樣。但因為 for 語法包含了「初始值」、「條件」、「結束迴圈的更新敘述」等，而 while 語法只包含「條件」的部分，使前者的執行次數可以一目了然。上述特性讓兩者的適用情況有區別： for 迴圈的使用情境，大多是用在迴圈執行次數「明確」的狀態。 while 迴圈的使用情境，更適合用在當迴圈執行次數「不確定」時。 小知識 不管是 for 或 while 迴圈，「完成結束的條件」都是非常重要的！若執行條件沒有設定好，可能會造成「無窮迴圈」，使程式跳不出迴圈。 了解更多 Kuro－流程判斷與迴圈：本文最主要的參考範例。 ALPHACamp－Loop 迴圈：了解 JS 的迴圈用法。 "},{"title":"#21 迴圈：for","date":"2023-11-13T16:00:00.000Z","url":"/javascript/20231114/1973875290/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"for 迴圈讓「重複做某件事」的程式變得更簡潔。 快速了解迴圈（loop）指：想要「重複做某件事，而數值會依重複次數的『遞增』或『遞減』的變化來完成退出迴圈的條件」。在 JS 中，常見的迴圈語法有 for 及 while 兩種。 不使用迴圈的案例假設要用 console.log() 從 1 印到 10 ，在沒有使用迴圈的情況下，同樣的東西必須要寫十次。 相同的案例，使用 for 迴圈只需要一半不到的行數。 for 迴圈一個典型的 for 語法會由小括號、初始值、條件、結束迴圈的更新敘述、敘述所組成。小括號內最左邊是「初始值」，用來初始化 for 迴圈中的計數器。中間的部分是「執行迴圈的條件」，當滿足該條件（結果為 true ）時，就會進入大括號的區塊，執行內部程式。最右邊則是在每次執行完大括號的程式碼後，會執行這段內容。當程式執行過右邊部分後，會再到中間條件區塊檢查，若是條件符合就繼續迴圈，否則就跳出迴圈區塊。 以上述為例： i = 1 是初始值。 i &lt;= 10 是條件。 i++ 是結束迴圈的更新敘述。 console.log(i) 是敘述，即函式要做的事。 了解更多 Kuro－流程判斷與迴圈：本文最主要的參考範例。 MDN－for 語法：了解 for 的常見用法。 ALPHACamp－Loop 迴圈：了解 JS 的迴圈用法。 "},{"title":"#20 條件判斷：三元運算子","date":"2023-11-12T16:00:00.000Z","url":"/javascript/20231113/4128159221/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"三元運算子也提供簡潔的條件判斷方式。 快速了解在 JS 的運算子種類中，存在一個用途跟 if...else 和 switch 很接近的運算子——三元運算子。三元運算子，又稱「條件運算子」，是 JS 中唯一用到三個運算元的運算子，以「條件」、「問號」、「冒號」三個元素所組成。在一個條件後面會跟著一個問號，如果條件是「truthy」，在冒號前的表達式會被執行；如果條件是「falsy」，在冒號後面的表達式會被執行。 案例說明：判斷變數 age 是否大於或等於 18，若是，則 status = &quot;成人&quot; ；若不是，則 status = &quot;小孩&quot; 。 條件判斷整理 條件判斷方式 特色 範例 if...else 推薦「入門學習者」使用 if (5 &gt; 2)&#123;console.log(”true”);&#125; else &#123; console.log(”false”);&#125; switch 推薦「複雜判斷」使用 switch()&#123;case1:…;&#125; 三元運算子 推薦「簡單判斷」使用 max = (a &gt; b)? a : b ; 小知識 三元運算子通常被用來當作 if...else 的簡潔寫法。 了解更多 MDN－三元運算子：了解三元運算子的常見用法。 ALPHACamp－流程控制 if&#x2F;else 條件判斷：複習三種流程控制的條件判斷方式。 #16 邏輯運算子：回顧「falsy」和「truthy」的觀念。 "},{"title":"#19 條件判斷：switch","date":"2023-11-11T16:00:00.000Z","url":"/javascript/20231112/52344673/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"switch 提供更簡潔的複雜條件判斷方式。 快速了解當需要複雜的條件判斷時，相較於 else...if ，更推薦使用 switch 語法。 switch 定義 switch 括號內的語法可以是「運算式」或「某個變數、值」。接下來，該內容會進入的 case 判斷流程，當它符合某個 case 條件時，會執行這個條件的陳述式；若所有 case 條件都不成立時，會執行 default 區塊的內容。 break 的重要性 case 區塊不像 if...else 使用大括號切分區塊，而是使用 break 指令來中斷執行。如果沒有插入 break 指令，可能會使所有 case 的內容都一起被執行。因此，建議務必要在 case 區塊結束前，加上 break 。 小知識 按照慣例， default 語句會是最後一個條件，但不一定要存在。 了解更多 MDN－switch：了解 switch 的常見用法。 MDN－break：預習 break 的使用方式。 "},{"title":"#18 條件判斷：if…else","date":"2023-11-10T16:00:00.000Z","url":"/javascript/20231111/961197172/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"當條件成立時會執行 if 陳述式裡的程式，否則執行另外一個陳述式。 快速了解流程控制的「條件語法」指：當指定的條件為 true 時，就會執行後續所指定的指令。JS 的條件語法有兩種： if...else switch if…else if...else 代表：當條件成立的時候會執行 if 陳述式裡的程式，否則執行另外一個陳述式。 if 陳述式裡的「條件式」是 true 或 false 的運算式。搭配之前提過「Boolean 的型別轉換」，所有 JS 資料都可以透過 ToBoolean 轉換成 true 或 false ，因此，條件式可以有任何內容。 else if當你需要新增多個條件時，多數程式語言可以用 elseif 表達。但 JS 沒有 elseif 可以使用。因此，我們可以使用「在 else 和 if中間夾著空白」的語法來取代它。 小知識 原則上， else if 沒有數量限制，但為了程式的可讀性與維護性，建議盡量減少 if...else 的條件數量。 了解更多 MDN－if…else：了解 if...else 的常見用法。 #17 自動轉型：回顧 Boolean 的型別轉換觀念。 "},{"title":"#17 自動轉型","date":"2023-11-09T16:00:00.000Z","url":"/javascript/20231110/266130255/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"不同型別的資料在運算時，JS 會先「自動轉型」。 基礎規則 如果其中一個是布林值，會將 true 轉為數字的 1， false 則變成數字的 0。 如果是字串與數字，會先透過 Number() 把字串轉為數字。 如果其中一個是「物件」型別，而另一方是基本型別時，會先透過物件的 valueOf() 方式取得對應的基本型別值。 複習賦值運算子 NaN 不等於 NaN ，不論是在相等或全等的情況。 當兩個「物件」比較時，要看兩者是否指向同一個「實體」，只有在指向同一個「實體」時才會回傳 true 。 複習比較運算子 兩者都是數字時，單純就其字面大小比較。 如果其中一個是數字，另一方不是，則會先將另一方轉為數字再比較。 如果兩者都是字串，則會依照字母順序比較。 如果其中一個是布林值，會將 true 轉為數字的 1， false 則變成數字的 0。 如果其中一個是「物件」型別，而另一方是基本型別時，會先透過物件的 valueOf() 方式取得對應的基本型別值。 小知識 字母順序依照的規則為字典序（standard lexicographical ordering），要注意大小寫字母的順序並不同。 了解更多 Kuro－Boolean 的真假判斷：本文最主要的參考範例。 Summer－強制轉型：了解詳細的 JS 轉型規則。 Genos－強制轉型及轉換技巧：回顧 JS 的轉型規則。 Oh-My-Dear-JavaScript：觀看 JS 真值表。 "},{"title":"#16 邏輯運算子","date":"2023-11-08T16:00:00.000Z","url":"/javascript/20231109/3042451770/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"JS 的邏輯運算子和多數程式語言不同，其結果值並非只有 true 或 false 。 快速了解邏輯運算子有三種：AND、OR、NOT，照理來說，運算後會得到 true 或 false 的結果。然而在 JS 中，只有 NOT 運算子才會回傳 true 或 false 。AND 和 OR 運算子的回傳結果則不一定是 Boolean ，還可能會是兩個數值的其中之一。讓我們先來了解三種邏輯運算子的定義，再理解 JS 中的特殊規則。 ANDAND 以 &amp;&amp; 符號表示。在「多數程式語言」中表示「條件 A &amp;&amp; 條件 B」，當 &amp;&amp; 左右兩側的值都是 true 時，會得到 true 的結果；若其中一方是 false 則會得到 false 。不過，在 JS 中不是這樣運作。 OROR 以 || 符號表示。在「多數程式語言」中表示「條件 A || 條件 B」，當 || 左右兩側有一方為 true ，則結果是 true ；只有在兩側都是 false 時才會得到 false 。不過，在 JS 中不是這樣運作。 NOTNOT 以 ! 符號表示。原本是 true 的結果經過 ! 轉換後會得到 false ；而原本是 false 的結果則會變成 true 。 Boolean 的型別轉換JS 中可以分成兩種「值」：不是 true 就是 false。 經過 ToBoolean 轉換後得到 false 的值，這些被稱為「Falsy」值。 其他的值，即經過 ToBoolean 轉換後得到 true 的值，這些被稱為「Truthy」值。絕大部分的情況都會變成 true ，因此以下只提及會變成 false 的特例： undefined null +0 , -0 , NaN &#39;&#39; , ”” （空字串）除此之外，所有的狀況都是 true ，例如：0、 [] 、 &#123;&#125; 、 function()&#123;&#125; 、 &quot;&#39;&#39;&quot; （這並不是空字串）。 &amp;&amp; 與 || 的特殊案例相較於其他程式語言，JS 針對 &amp;&amp; 與 || 有不同的規範：結果並非布林值的 true 或 false ，而是兩個數值的其中之一。 &amp;&amp; 與 || 運算子在判斷時，會先對左邊的數值進行檢查： 若是 Boolean 就在做後續判斷；若不是，則會透過 ToBoolean 判斷是「truthy」或「falsy」，並以此轉換乘對應的 true 跟 false 。 對 &amp;&amp; 來說，若第一個數值轉換為 true ，則回傳第一個數值；否則回傳第二個數值。 對 || 來說，若第一個數值轉換為 false ，則回傳第二個數值；否則回傳第一個數值。 小知識 需要判斷某數值 Boolean 轉換後的結果時，可以透過兩次「NOT」操作，用 !!xxx 來取代 Boolean(xxx) 。 Falsy 值還有一種：本來就是 false 值者。同時要注意，Boolean(false) 和 Boolean(&quot;false&quot;) 的結果不同，前者是 false ；後者是字串，所以結果為 true。 了解更多 Kuro－Boolean 的真假判斷：本文最主要的參考範例。 Vicky－Truthy 與 Falsy：了解 Truthy 與 Falsy 的差異。 "},{"title":"#15 逗號運算子","date":"2023-11-07T16:00:00.000Z","url":"/javascript/20231108/1989175817/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"逗號運算子可以分隔運算式，或同時宣告多組變數。 快速了解逗號運算子主要工作為：用逗號分隔運算式，使其依序由左至右執行，並且會回傳最後一個運算式的值。 基本用法逗號運算子由逗號 , 表示，透過逗號運算子可以將多組運算式看作是同一個，最常出現在 for 迴圈中。 進階用法此外，逗號運算子也可以宣告變數。具體來說，可以同時宣告多組變數，且給予預設值。值得注意的是，若使用錯誤方式同時宣告多組變數，可能會造成「全域變數」的大麻煩！以下展示正確與錯誤的宣告方式。 錯誤改寫看似同時用 var 宣告 a、b 變數，並賦值「10」。然而，變數 b 並沒有被透過 var 宣告，而是一個全域變數。 了解更多 Kuro－Boolean 的真假判斷：本文最主要的參考範例。 MDN－逗號運算子：觀看更多逗號運算子的範例。 "},{"title":"#14 比較運算子","date":"2023-11-06T16:00:00.000Z","url":"/javascript/20231107/1239253188/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"相等會自動轉型，全等不會自動轉型。 快速了解比較運算子的用塗是比較運算子兩側數值，不論數值為純值、物件、運算式或函數回傳結果，比較結果都是 true 或 false。針對不同型別的數值，會先自動轉型到同樣型別後，再做比較。 前情提要只有一個等號，是「指定、賦值」的意思。當要比較數值時，有兩種表現方式：兩個等號的「相等」或三個等號的「全等」。這是 JS 最容易搞混的觀念之一！ 相等相等，以兩個等號 == 表示，在比較判斷時會自動轉型，是「寬鬆的等於」。當兩個不同的「資料型別」比較時，會觸發自動轉型，導致常常會出現莫名其妙的比較結果，因此，不建議使用相等來比較。 全等全等，以三個等號 === 表示，在比較判斷時不會自動轉型，是「嚴格的等於」。當兩個不同的「資料型別」比較時，不會自動轉型，因此，只會在雙方的「數值」與「型別」都相同時才回傳 true。在任何時刻都建議使用全等來比較。 不等於不等於有兩種版本：寬鬆的不等於 != 和嚴格的不等於 !== 。觀念和上述內容相同，前者會做自動轉型，後者不會做自動轉型。 重點回顧相等 == 和全等 === 都是比較的意思，它們的差異不是「全等會檢查型別而相等不會」，是：全等不會替數值做自動轉型，相等會做自動轉型。 運算子整理 運算子 說明 範例 結果 &#x3D;&#x3D; 相等，寬鬆的等於 1 == “1” true &#x3D;&#x3D;&#x3D; 全等，嚴格的等於 1 === “1” true !&#x3D; 寬鬆的不等於 10 != &quot;10&quot; false !&#x3D;&#x3D; 嚴格的不等於 10 !== &quot;10&quot; true 小知識 除了相等和全等之外，比較運算子還包括：大於 &gt; 、大於等於 &gt;= 、小於 &lt; 、小於等於 &lt;= 。 =&gt; 不是運算子，而是 ES6 的箭頭函式。 了解更多 Kuro－「比較」與自動轉型的規則：本文最主要的參考範例。 "},{"title":"#13 賦值運算子","date":"2023-11-05T16:00:00.000Z","url":"/javascript/20231106/2323189855/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"賦值運算子能讓運算的處理更簡潔、便利。 快速了解賦值運算子，或稱指派、指定運算子，用途為：指定一個值給一個變數。 基本用法只有一個等號 = 是「指定、指派、賦值」的意思。例如下方案例：用 &#x3D; 符號將右側的運算式結果「指派」給等號左側的變數 a。 進階用法賦值運算子還可以結合數學運算子，會先將等號右側的內容運算完成，再指定至等號左側的變數，例如： += 、 -= 。當賦值運算子的前後都是「數值」或「布林值」時，會視為數字後運算。而當其中一個是字串時，則觸發自動轉型，用字串聯結。例如下方案例： a += 10 代表 a = a + 10。 運算子整理 運算子 說明 範例 &#x3D; 將 y 值指定給 x 變數 x = y +&#x3D; 意思跟 x = x + y 一樣，將 x、y 相加後的值指定回 x 變數 x += y -&#x3D; 意思跟 x = x - y 一樣，將 x、y 相減後的值指定回 x 變數 x -= y *&#x3D; 意思跟 x = x * y 一樣，將 x、y 相乘後的值指定回 x 變數 x *= y &#x2F;&#x3D; 意思跟 x = x / y 一樣，將 x、y 相除後的值指定回 x 變數 x /= y %&#x3D; 意思跟 x = x % y 一樣，將 x 除以 y 的餘數指定回 x 變數 x %= y 小知識 實際上，賦值運算子的進階用法就是一般四則運算的懶人寫法。 了解更多 Kuro－Boolean 的真假判斷：本文最主要的參考範例。 JStips－賦值運算子：觀看更多賦值運算子的範例。 "},{"title":"#12 算術運算子：一元運算子","date":"2023-11-04T16:00:00.000Z","url":"/javascript/20231105/1630436862/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"一元運算子只需要單個數值就可以完成運算，有正號、負號、遞增、遞減四種。 快速了解算術運算子還有一種——只需要單個數值即可完成運算的「一元運算子」。 正號與負號正號 + 與負號 - 分別代表數字的「正數」與「負數」的狀態。 當後面是數字時，結果會是該數值的正數或負數。 當後面是非數字的基本型別時，會先以 Number() 嘗試轉型，再由正、負號決定其數值。 當後面是物件型別時，會先以 valueOf() 取得數值，再由正、負號決定其數值。 若得到 NaN，結果就是 NaN。 遞加與遞減「遞增」指變數遇上 ++ 就會加 1，也可以想成是 a=a+1；「遞減」指變數遇上 -- 就會減 1，也可以想成是 a=a-1。值得注意的是，這兩個運算子在變數的前、後，會產生不同的結果。當運算子在變數後面時，回傳結果會是「原始數值」；當運算子在變數前面時，回傳結果會是「+1 之後的結果」。但事後將結果印出時，回傳結果都會是「+1 之後的結果」。 運算子整理 運算子 說明 範例 + 一元正號運算子 +8 - 一元負號運算子 -x ++ 遞增運算子 a++ – 遞減運算子 5— 小知識 加號和 Number() 有一樣的數字轉型效果。 了解更多 Kuro－「比較」與自動轉型的規則：本文最主要的參考範例。 MDN－一元正號運算子（+）：觀看更多一元正號運算子的自動轉型範例。 MDN－一元負號運算子（-）：觀看更多一元負號運算子的自動轉型範例。 MDN－遞增運算子（++）：觀看更多遞增運算子的範例。 MDN－遞減運算子（–）：觀看更多遞減運算子的範例。 "},{"title":"#11 算術運算子：四則運算","date":"2023-11-03T16:00:00.000Z","url":"/javascript/20231104/3439418316/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"算術運算子除了能夠進行四則運算，還影響著型別間的自動轉型問題。 快速了解算術運算子包括數學四則運算的加、減、乘、除和取餘數。運算式會遵守「由左至右」且「先乘除後加減」的模式進行運算，需要時可加上小括號 () 輔助。 加號加法運算子以加號 + 表示。 當前後兩者都是數字時，計算結果是兩個數值的和。 當其中一個是 NaN 時，結果必定也是 NaN。 Infinity 與 -Infinity 的情況： Infinity 與 Infinity 相加，結果是 Infinity 。 -Infinity 與 -Infinity 相加，結果是 -Infinity 。 Infinity 與 -Infinity 相加，結果是 NaN。 當其中一個不是數字時，會觸發自動轉型。 若其中一個是字串，另一端會變「自動轉型」為字串後，連接在一起。 當另一端是數字、布林值、物件時，會以 .toString() 轉型。 當另一端是 null、undefined 時，會以 String() 將它們轉成 “null” 與 “undefined” 。 減號減法運算子以減號 - 表示。 當前後兩者都是數字時，計算結果是兩個數值的差。 當其中一個是 NaN 時，結果必定也是 NaN。 Infinity 與 -Infinity 的情況： Infinity 與 Infinity 相減，結果是 NaN。 -Infinity 與 -Infinity 相減，結果是 NaN。 -Infinity 與 Infinity 相減，結果是 -Infinity 。 Infinity 與 -Infinity 相減，結果是 Infinity 。 當其中一個不是數字時，會觸發自動轉型。 若其中一個是非數字的基本型別時，會以 Number() 嘗試轉為數字。 若其中一個是物件型別時，會先以 valueOf() 取得數值再計算；若物件沒有 valueOf() 方法的話，則會先透過 toString() 轉成字串，再以 Number() 後的數字進行運算。 乘號乘法運算子以星號 * 表示。 當前後兩者都是數字時，計算結果是兩個數值的乘積。 若計算結果超出數字範圍，會依結果是正數或負數決定是 Infinity 或 -Infinity。 當其中一個是 NaN 時，結果必定也是 NaN。 若其中一個不是數字時，JS 會先嘗試以 Number() 進行轉型再運算。 除號除法運算子以斜線 / 表示。 當前後兩者都是數字時，計算結果是兩個數值的商。 當其中一個是 NaN 時，結果必定也是 NaN。 若其中一個不是數字時，JS 會先嘗試以 Number() 進行轉型再運算。 在被除數為 0 時，有三種情況： 除數為正數，結果為 Infinity。 除數為負數，結果為 -Infinity。 除數為 0，結果為 NaN。 取餘數取餘數運算子以百分比符號 % 表示。 當前後兩者都是數字時，計算結果是除法運算後的「餘數」。 當被除數是 Infinity 或 -Infinity 時，取餘數結果會是 NaN。 當被除數是一般數值，而除數為 Infinity 時，結果為被除數。 當被除數是一般數值，而除數為 0 時，結果為 NaN。 當其中一個是 NaN 時，結果必定也是 NaN。 若其中一個不是數字時，JS 會先嘗試以 Number() 進行轉型再運算。 運算子整理 運算子 說明 範例 + 加法 10 + ”hello” - 減法 100 - false * 乘法 100 * 5 &#x2F; 除法 20 / 2 % 取餘數 100 % 33 小知識 算術運算子還有一種：指數運算子，以雙星號 ** 表示，用來計算以 a 為底的 b 次方。 了解更多 Kuro－運算式與運算子：本文最主要的參考範例。 MDN－加法運算子（+）：觀看更多加法運算子的自動轉型範例。 MDN－減法運算子（-）：觀看更多減法運算子的自動轉型範例。 Genos－強制轉型及轉換技巧：預習 JS 的轉型規則。 "},{"title":"#10 運算式與運算子","date":"2023-11-02T16:00:00.000Z","url":"/javascript/20231103/808747970/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"JS 可分為陳述式與運算式，最關鍵的差異為是否會回傳結果。 快速了解JS 的語法基本上可以分為兩類：陳述式與運算式。 陳述式（Statement）：會執行一些程式碼，且不會回傳結果，像是變數宣告、賦值、流程判斷、迴圈等。 運算式（Expression）：會回傳結果。換言之，任何可回傳結果都可稱為運算式，像是純值、變數、運算子、執行函式等。 重點整理 是否會回傳結果？ 常見分類 陳述式 不會回傳結果。 變數宣告、賦值、流程判斷、迴圈等。 運算式 會回傳結果。 純值、變數、運算子、執行函式等。 運算子在運算式中，存在很多種運算子（Operator），它們可以對值進行運算，進而得到運算結果。常見運算子包含：算術運算子、位元運算子、比較運算子、賦值運算子、邏輯運算子等。 小知識 運算式又稱「表達式」。 學習陳述式和運算式概念時，建議搭配 Chrome 的開發者工具。 了解更多 卡斯柏－JavaScript 表達式觀念及運用 - JS Expression：熟悉陳述式與表達式的差異。 itsems－Javascript 的表達式和陳述式：觀看更多表達式案例。 "},{"title":"#9 物件型別：陣列","date":"2023-11-01T16:00:00.000Z","url":"/javascript/20231102/712042596/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"陣列是有順序性的集合，透過內建函式可以新增、刪除陣列中的元素。 快速了解陣列可被視為一種特別的「物件」，同樣是零至多個元素的集合，其值可以是原始的資料型別、另一個陣列、物件甚至函式。與物件不同，陣列是有順序性的集合。 建立陣列陣列有兩種宣告方式：建構式與陣列實字。 建構式：用 new 關鍵字加上 Array() 來宣告一個物件。 陣列實字：用 [] 就可以宣告一個物件。 陣列索引陣列索引是由 0 開始計算，以下方案例來說，陣列索引依序是 0、1、2、3。陣列長度則可以透過 array.length 得知。 陣列元素取值陣列元素的取值方式為 array[number] ，number 指元素的索引值。舉例來說：陣列的第一個元素，要透過 array[0] 取得。 新增元素陣列有兩種新增元素的方式： push() 、 unshift() 。 push() ：加入項目至陣列末端。 unshift() ：加入項目至陣列前端。 刪除元素陣列有三種刪除元素的方式： pop() 、 shift() 、 splice() 。 pop() ：移除陣列末端的項目。 shift() ：移除陣列前端的項目。 splice() ：移除指定索引位置的項目，並可指定欲移除其後的多少個項目。 陣列判斷使用 typeof 檢查一個陣列，會得到 “object” 的結果。當我們要檢查一個變數是陣列而非物件時，可以透過 isArray() 的方法判斷： 小知識 array.length 的值可被覆寫，因此，陣列長度可以透過改變 length 屬性而更動。 了解更多 MDN－Array：了解陣列的更多應用。 MDN－Array.length：熟悉 array.length 的操作邏輯。 卡斯柏－JS 常見陣列方法：理解 JS 常見的陣列方法。 "},{"title":"#8 物件型別：物件","date":"2023-10-31T16:00:00.000Z","url":"/javascript/20231101/3927311135/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"物件型別對於 JS 來說是非常重要且容易混淆的概念，其包含物件、陣列、函式等值。 快速了解複習一下，除了六種基本型別之外的值，都可以被歸類為「物件型別」。因此，物件、陣列、函式都屬於物件型別。 物件定義一個物件（object）可以是個零至多種屬性的集合，而屬性是名稱（name）與值（value）之間的關聯。一個屬性的「值」可以是某個基本型別，也可以是另一個物件，甚至是一個函式。物件內容來源有兩種：瀏覽器預先定義、開發者自己定義。 瀏覽器或執行環境預先定義，例如：window、Date、Math 等物件。 開發者自己定義物件的屬性與內容。 建立物件物件有兩種宣告方式：物件建構式與物件實字。 物件建構式：用 new 關鍵字加上 Object() 來宣告一個物件。 物件實字：用 &#123;&#125; 就可以宣告一個物件。 物件屬性取值物件的屬性有兩種取值方式：點記法與括弧記法。 點記法：使用 . （點）進行取值，語法為 objectName.propertyName。 括弧記法：使用 [] （中括弧）進行取值，語法為 objectName[&quot;propertyName&quot;]。 新增屬性使用 = （等號）指定，即可為物件新增屬性。 刪除屬性使用 delete 關鍵字，即可刪除屬性。屬性刪除後，該變數的值會變成 undefined。 小知識 因為 JSON 的特性，當屬性名稱是數字開頭時，使用點記法取值會出現錯誤，例如：”001” 。這時就必須改成括弧記法 objName[”001”] 的方式才能正確存取值。 當我們存取物件中不存在的屬性時，會回傳 undefined。因此，可以透過檢查某屬性是否為 undefined，來判斷屬性是否存在。除了此方式，還有兩種進階方法：in 運算子與 hasOwnProperty() 函式。 了解更多 卡斯柏－JS 物件名詞解釋及常見觀念問題：了解物件相關知識。 JSON 精要讀書紀錄－JSON 語法：預習 JSON 格式的使用方式。 MDN－關係運算子：in 運算子判斷屬性是否存在。 MDN－Object.prototype.hasOwnProperty()：hasOwnProperty() 函式判斷屬性是否存在。 "},{"title":"#7 基本型別：布林值、null、undefined 與 symbol","date":"2023-10-30T16:00:00.000Z","url":"/javascript/20231031/2849981050/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"簡介布林值、 null 、 undefined 與 symbol 等資料型別的常見應用。 快速了解boolean布林值（boolean）通常用在判斷式，作為控制程式流程的用途。其值只有兩種：true 及 false。 nullnull 型別只有一種值——null（空值），代表「此變數可能曾經有值，也可能沒有值，現在沒有值」。例如：以下案例中的 a ，明確表示此變數沒有值。 undefinedundefined 型別也只有一種值——undefined，代表「此變數還沒有給值，所以不知道是什麼」。例如：以下案例的 b，當變數 b 被宣告時，其值還沒有定義或還未指定的情況下，預設值會是 undefined。 symbolsymbol 是 ES6 新增的基本資料型別，用來表示獨一無二的值，以避免名稱相同造成的衝突。 小知識 在 JS 判斷比較的運算式中，所有內容都可以轉換為布林值。 typeof null 回傳結果是“obejct” ，而非 null。這其實是一個 Bug！但因為修正該問題，會影響太多舊程式，最後只好保留這個錯誤。 了解更多 fooish－JavaScript ES6 Symbol 資料型態：了解 Symbol 的使用情境。 stackoverflow－Why is typeof null “object”?：明白 typeof null 為什麼是 “obejct” 。 "},{"title":"#6 基本型別：數字","date":"2023-10-29T16:00:00.000Z","url":"/javascript/20231030/4193996687/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"數字型別除了基礎運算， NaN 與浮點數問題也相當重要。 快速了解JS 只有一種數字的型別，不論整數、浮點數，或 Infinity（無限大）、-Infinity（負無限大）及 NaN（不是數值）等特殊數字，都屬於 number 型別。 數字使用方式數字有兩種使用方式：字面常量與科學記號表示法。 字面常量： 科學記號表示法： 無限的計算方式Infinity 與 -Infinity 分別代表數學上的無限大與負無限大。任何正數除以 0，結果會得到 Infinity；相反的，任何負數除以 0，結果會是 -Infinity。 NaNNaN 不等於任何數字，甚至是自己。因此，它與任何數字運算，結果都是 NaN。然而，使用 typeof 判斷 NaN 型別時，回傳結果卻是數字。那麼該如何判斷一個變數是否為 NaN 呢？可以透過 isNaN(value) 函式來協助： 浮點數JS 在運算 0.1 + 0.2 時，其結果不是 0.3，而是 0.30000000000000004 。因此執行 0.1 + 0.2 === 0.3 會回傳 false 的結果。這是因為 JS 採用「IEEE 754」六十四位元二進位浮點數算術標準，十進位的小數無法完美的用二進位表示，只能用無限循環的位數來趨近於十進位的小數，導致還原時的小數不夠精準。透過 toFixed() 和 toPrecision() 設定精確度，可以避免浮點數問題。例如：設定精確到小數第一位。 小知識 數字型別常搭配 Math 物件使用，例如： Math.PI 可用來計算圓周和直徑。 了解更多 MDN－Math 物件：了解 Math 的常見用法。 MDN－NaN：了解 NaN 的使用方式與相關限制。 Floating Point Math：解釋 0.1 + 0.2 !== 0.3 的原理與彙整各程式語言計算方式。 "},{"title":"#5 基本型別：字串","date":"2023-10-28T16:00:00.000Z","url":"/javascript/20231029/3345115497/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"字串型別原本專門儲存、處理文字，樣板字面值的出現，大幅提升字串的靈活度。 快速了解在 JS 中，文字會以字串表示。 字串使用方式字串會用一組單引號 ’’ 或雙引號 ”” 包住，且兩者不可混用。 在單引號中包覆單引號，或在雙引號中包覆雙引號都會出現問題。如果非用不可，可以透過跳脫字元 \\ 處理： 遇到多組字串時，可以透過加號 + 連接： 或是在多行字串時，使用反斜線 \\ 連結： 樣板字面值樣板字元值（template literal）是 ES6 新增的特殊字串，支援多行字串、允許將變數嵌入字串，且能夠內嵌運算式，大幅提升字串的靈活度。樣板字元值由反引號 &#96;&#96;&#96;&#96; 所包覆，由一般字串、錢字號 $ 、大括弧 &#123;&#125; 組成。 支援多行字串： 允許將變數嵌入字串 內嵌運算式： 小知識 連接多行字串時，反斜線 \\ 後方不可以有任何內容，包括空白字元。 反引號位於鍵盤左上方，Esc 底下。 了解更多 MDN－樣板字面值：了解樣板字面值的詳細內容與更多範例。 PJCHENder－樣板字面值：了解樣板字面值的應用。 菜鳥教程－HTML DOM console.log() 方法：簡介 console.log 用法。 "},{"title":"#4 資料型別簡介","date":"2023-10-27T16:00:00.000Z","url":"/javascript/20231028/764880996/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"變數沒有型別，值才有。 快速了解變數本身不帶有資料型別的資訊，其中的「值」或「物件」才有。換句話說，變數只是用來作為取得值或物件的參考。JS 的資料型別分為兩大類：基本型別（Primitives）與物件型別（Object）。 資料型別總共有七種資料型別：六種基本型別及一種物件型別。 字串（String）。 數字（Number）。 布林值（Boolean）。 null。 undefined。 symbol。 物件型別（Object）。 型別判斷可以透過 typeof 運算子判斷型別。 型別整理 資料型別 說明 String 字串。 Number 數字，可以是整數或小數。 Boolean 布林值，只有 true、false 兩種。 null 空值，表示參考值不存在。 undefined 未定義，宣告變數卻未指派內容給它。 symbol 符號，表示獨一無二的值。 object 物件、陣列、函式都屬於物件型別。 小知識 JS 是一種「弱型別語言」，宣告變數時，可以不指定該值的資料型別。編譯時，JS 會將該變數轉換成「可以被執行」的資料型別，並強制執行。 基本型別之外的值，都是「物件型別」。 了解更多 MDN－資料結構與型別：了解 JS 各資料型別的基本內容。 Yi-Ning－關於 JavaScript 的弱型別特性：了解弱型別語言的定義。 "},{"title":"#3 變數","date":"2023-10-26T16:00:00.000Z","url":"/javascript/20231027/1250803838/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"變數是儲存資料的容器，可以幫助我們紀錄、使用資訊。 快速了解變數是什麼？變數（Variables）是用來儲存資料和進行運算的基本單位，可以將變數想像為一個盒子，用來存放資料。變數儲存的資料被稱為「值」（value）。 變數的命名規則 變數的第一個字母必須是英文字母、底線 _ 或錢字號 $ ，後面可以是英文字母、底線 _ 或錢字號 $ 及數字 變數名稱不可以是保留字和關鍵字。 區分大小寫， app 和 App 會被視為不同變數。 變數的宣告方式變數有三種宣告方式： var 、 let 、 const 。差異為變數作用範圍、能否重複宣告等。變數必須經過宣告才能使用，如果在沒有宣告變數的情況下使用，會出現錯誤。 小知識 JS 支援 Unicode，變數名稱可以用中文命名。但基於開發習慣，仍應該避免使用英文字母、底線（_）或錢字號（$）以外的字原來命名變數。 事實上，變數還有第四種宣告方式：無宣告。但沒有經過宣告的變數都會變成全域變數，可能會造成維護困難，因此非常不建議這麼做！ 了解更多 MDN－存儲您需要的資訊 - 變數：詳細說明 JS 變數的使用規則。 W3School－JavaScript Reserved Words：JS 的保留字列表。 阿建－JavaScript 變數宣告有哪些?必須弄懂的4個重點：了解 JS 的四種變數宣告。 Roy Kwok－Unicode 與 UTF-8 的關係？：說明 Unicode 如何編譯中文字元。 "},{"title":"#2 JS 發展簡史","date":"2023-10-25T16:00:00.000Z","url":"/javascript/20231026/1784042972/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"JavaScript 如何從「網路特效工具箱」發展成網頁設計中不可或缺的一部份？ 背景故事JS 最初的設計目標是：在文件閱讀上增加互動，讓網站動起來。1995～2010 年這段期間，處於瀏覽器的戰國時代，各種瀏覽器百花齊放，且各家標準不一，造成網頁維護困難。ECMA 組織於 1997 年發表 JS 的標準化版本——ECMAScript，使 JS 開始獲得廣泛支持，成為瀏覽器唯一指定的內建程式語言。2015 年，ECMAScript 第六版本（簡稱 ES2015、ES6）發布前，有很多 JS 的延伸語言存在，例如：CoffeeScript、TypeScript、Dart 等，這些都是使用者因應需求，自行開發的程式語言。ES6 整合了上述延伸語言的優點並新增許多重要規範，使 JS 更強大，以便開發複雜的應用程式。從此，ES6 成為主流使用的 JS 標準。 小知識 Java 和 JavaScript 之間類似於「臘腸」和「臘腸狗」的關係——沒有關係。 TypeScript 是有型態規範的 JS，由微軟開發，有較嚴謹的寫法。直到今日，仍有許多開發者使用。 2015 年之後，ECMAScript 在每年六月會推出最新的版本，例如：ES2016、ES2017⋯⋯，這些新版本被統稱為「ES6+」。 了解更多 Kuro Hsu－重新認識 JavaScript: Day 02 JavaScript 簡介：圖文並茂講古時間。 ALPHACamp－JavaScript 前世今生：了解前端發展歷史。 "},{"title":"#1 JS 是什麼？","date":"2023-10-24T16:00:00.000Z","url":"/javascript/20231025/1925797630/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"JavaScript 不是魔法，而是一種實現多樣化功能的程式語言。 快速了解JS 是什麼樣的程式語言？ JS 是一種腳本程式語言，具有簡單、易學、易用的特性。 JS 是一種直譯式語言，其程式碼由上到下執行，且能夠立即得到執行結果。 JS 是一種動態程式，會在瀏覽器上調整 HTML 與 CSS，以產生新的內容，並在頁面中呈現。因為此特性，使它必需在 HTML、CSS 之後載入，否則可能會發生錯誤。 JS 的功能JS 可以在網頁中展現複雜的動態功能，例如：表單驗證、彈跳動畫等互動行為。基礎的 JS 可以進行四則運算、數字排序、判斷大小寫等。若加上應用程式介面（API），還能提供 JS 額外的功能，例如：內容即時更新、繪製 2D&#x2F;3D 圖形、影片播放控制。 JS 載入方式JS 主要有兩種載入方式：內部與外部。 內部的 JS：在 HTML 檔案的 &lt;/head&gt; 結尾標籤前加入以下文字。 外部的 JS：建立一個以 .js 為副檔名的檔案，將 JS 內容寫在該檔案內，並在 HTML 檔案的 &lt;/head&gt; 或 &lt;/body&gt; 結尾標籤前加入以下文字。 JS 註解方式JS 有兩種註解方式：單行和多行。 單行註解：文字寫在兩個斜線 // 之後。 多行註解：文字寫在 /* 和 */ 之間。 了解更多 MDN－JavaScript 是什麼？：詳細說明 JS 的能力與使用方式。 MuleSoft Videos－What is an API?：了解 API 在網頁中扮演的角色與功能。 "},{"title":"⚡️ 最聰明的高效能溝通法","date":"2023-10-23T16:00:00.000Z","url":"/read/20231024/861377249/","tags":[["閱讀心得","/tags/%E9%96%B1%E8%AE%80%E5%BF%83%E5%BE%97/"]],"categories":[["DoRead","/categories/read/"]],"content":"我們平均花 26 秒閱讀一篇內容，卻仍用 80 年代的舊方式溝通。 為什麼重要：資訊爆炸的現在，若使用冗長的舊方法溝通，每天將會有數十億個文字成為無法被消化的成本，這些巨量文字不斷地轟炸你、浪費你的時間。「聰明簡潔溝通法」能為你帶來自信，成為更有力的溝通者，同時也能讓更多人聽見你的聲音。 什麼是「聰明簡潔溝通法」？「聰明簡潔溝通法」有四個核心觀念： 強大的「引子、標題」。 有力、令人難忘的「導言」。 交代背景脈絡的「為什麼重要」。 補充說明的「了解更多」。 透過這四個核心觀念的系統，能夠讓你用更少的時間分享更多的價值。「少即是多」的寫作精神，才是符合當前網路世代的交流模式。並且，不論簡報、電子郵件、社群軟體，任何溝通方法都適用！ 了解更多 Axios.com：看看聰明簡潔溝通法如何運作。 《聰明簡潔的溝通》：書籍購買連結。 書籍資訊 書名：聰明簡潔的溝通：200 字寫重點，26 秒贏得注意力 作者：吉姆．范德海、麥克．艾倫、羅伊．史瓦茲 出版社：天下文化 "},{"title":"404","date":"2023-10-27T16:00:00.000Z","url":"/404.html","categories":[[" ",""]],"content":"這是一個不存在的頁面很抱歉，你目前存取的頁面並不存在。預計將在約 5 秒後返回首頁。如果你很急著想看文章，你可以 點這裡 返回首頁。 let countTime = 5; function count() { document.getElementById('timeout').textContent = countTime; countTime -= 1; if(countTime === 0){ location.href = ''; } setTimeout(() => { count(); }, 1000); } count(); "},{"title":"About","date":"2023-10-28T15:58:19.043Z","url":"/about/index.html","categories":[[" ",""]]},{"title":"archives","date":"2023-10-24T16:00:00.000Z","url":"/archives/index.html","categories":[[" ",""]]},{"title":"category","date":"2023-10-24T16:00:00.000Z","url":"/categories/index.html","categories":[[" ",""]]},{"title":"search","date":"2023-10-24T16:00:00.000Z","url":"/search/index.html","categories":[[" ",""]]},{"title":"tags","date":"2023-10-24T16:00:00.000Z","url":"/tags/index.html","categories":[[" ",""]]}]